\documentclass{article}
\usepackage{cmap}
\usepackage[T1]{fontenc} 
\usepackage[cp1251]{inputenc}
\usepackage[russian]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{wrapfig}
%\usepackage{indentfirst}
\usepackage{setspace}
\usepackage[pdftex]{graphicx}
\usepackage[large, bf]{caption}
\usepackage{subcaption}
\usepackage{textcomp}
\usepackage{color}
\usepackage{hyperref}
%\usepackage{array}
\usepackage{courier}
\usepackage{listings}
\lstset{language = Python}
\topmargin = -1.5cm
\marginparwidth = -1cm
\marginparsep = 0pt
\textwidth = 16cm
\textheight = 24cm
\oddsidemargin = 0.2cm
\parindent = 0.5cm
\lineskip = 0.025cm
\parskip = 0.2cm

\definecolor{darkgreen}{rgb}{0,0.5,0}
\definecolor{darkblue}{rgb}{0,0,0.5}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\hypersetup{colorlinks, linkcolor=blue}

\lstset{ 
numbers=left,
numbersep=10pt,
numberstyle=\small\usefont{T1}{pcr}{m}{n}\color{gray},
keywordstyle=\normalsize\usefont{T1}{pcr}{b}{n}\color{darkblue}, 
language=Python, % the language of the code
keywords=[2]{np, v1_vector, v2_non_vector, v3_part_vector, ...},
keywordstyle=[2]\normalsize\usefont{T1}{pcr}{b}{n}\color{darkgreen}, 
}

\begin{document}


\begin{titlepage}
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}} 
\centering 
{
    \centering
   
        \centering
        \large Московский государственный университет имени М.~В.~Ломоносова\\[0.5cm]
        \normalsize Факультет вычислительной математики и кибернетики 
}

\HRule\\[7cm]
{
 \bfseries \upshape
 \LARGE   Отчет по заданию №1 <<Изучение Python, NumPy>>\\ Практикум на ЭВМ 317 группы \\ 2015-2016 учебный год  \\[0.2cm]
    ~\\[20mm]
}

{
\large
подготовила студентка $317$ учебной группы факультета ВМК МГУ \\
Шолохова Татьяна\\
}
\vspace{8cm}
{\large Москва, \today}
\vfill
\end{titlepage}
\fontsize{13pt}{14pt}\selectfont
\tableofcontents
\pagebreak

\section{Постановка задания}
    Требовалось для каждой из данных задач:
    \begin{enumerate}
        \item В отдельном Python модуле написать на Python + NumPy не менее трёх вариантов кода различной эффективности(в том числе один полностью векторизованный вариант и один вариант без векторизации).
        \item Вычислить скорость работы на нескольких тестовых наборах разного размера.
        \item Проанализировать полученные данные о скорости работы разных реализаций.
        \item Получить выводы.
    \end{enumerate}
\pagebreak
\section{Задача 1}
    \subsection{Условие}
    Подсчитать произведение ненулевых элементов на диагонали прямоугольной матрицы. (Можно считать, что на диагонали матрицы есть ненулевые элементы)
    
    \subsection{Решение 1. Векторизованное}
    С помощью функций NumPy сначала находится массив значений на диагонали матрицы($np.diag()$), далее перемножаются($np.prod()$) все ненулевые элементы($np.nonzero()$) этого массива.~\lstinputlisting[firstline = 7, lastline = 9]{task1.py}
    
    \subsection{Решение 2. Невекторизованное}
    С помощью цикла $for$ все элементы диагонали матрицы просматриваются, сравниваются с нулем и при необходимости учитываются в ответе.~\lstinputlisting[firstline = 15, lastline = 20]{task1.py}
    
    \subsection{Решение 3}
    С помощью функций NumPy сначала находится массив значений на диагонали матрицы($np.diag()$), далее с помощью цикла $for$ все значения этого массива просматриваются, сравниваются с нулем и при необходимости учитывются в ответе.~\lstinputlisting[firstline = 26, lastline = 32]{task1.py}
    \pagebreak
    \subsection{Вычисление скоростей}
        В модуле $task1.py$ описана функция $gen(size)$, которая в зависимости от значения параметра $size$ генерирует случайные тестовые данные разных объёмов. В данном случае матрицу $X$ со значениями:~ $-1$, $0$, $1$.\\
        Время измеряется в IPython Notebook функцией $\verb"%timeit -o -q"$.\\       
        \begin{tabular}[t]{|p{5cm}|c|c|c|c|c|}
			\hline
            Значение $size$ & $0$ & $1$ & $2$ & $3$ & $4$ \\
            \hline
            Размеры матрицы $X$ & $50 \times 30$ & $100 \times 120$ & $520 \times 500$ & $1000 \times 1020$ & $5020 \times 5000$\\
            \hline
            Время работы векторного решения & $38~\mu{s}$ & $40~\mu{s}$ & $59~\mu{s}$ & $159~\mu{s}$ & $0.73~ms$\\
            \hline
            Время работы невекторного решения & $59~\mu{s}$ & $193~\mu{s}$ & $1~ms$ & $1.8~ms$ & $10~ms$\\
            \hline
            Время работы решения 3& $51~\mu{s}$ & $119~\mu{s}$ & $0.5~ms$ & $1~ms$ & $5~ms$\\
            \hline
        \end{tabular}
        
    \subsection{Вывод}
    \begin{figure}[!h]
        \centering
		\includegraphics[width = 0.8\textwidth]{task1.pdf}
        \caption{Задача 1. График зависимости скоростей разных реализаций от объёма входных данных}
        \label{task1}
   \end{figure}
    Как видно на рисунке \ref{task1}, векторная реализация работает быстрее остальных, частично-векторная реализация работает быстрее невекторной, но медленнее векторной, и невекторизованная работает медленнее остальных. Это соответствует теоретическим соображениям.        
\pagebreak    
\section{Задача 2}
    \subsection{Условие}
     Дана матрица $X$ и два вектора одинаковой длины $i$ и $j$. \\
     Построить вектор $np.array([X[i[0], j[0]], X[i[1], j[1]],\dots, X[i[N-1], j[N-1]]])$
   
    \subsection{Решение 1. Векторизованное}
    Используется сложная индексация NumPy 
   ~\lstinputlisting[firstline = 8, lastline = 9]{task2.py}
    
    \subsection{Решение 2. Невекторизованное}
    С помощью цикла $for$ просматриваются все значения векторов $i, j$, и нужный элемент матрицы $X$ добавляется в ответ.
    ~\lstinputlisting[firstline = 16, lastline = 20]{task2.py}
    
    \subsection{Решение 3}
    Дважды используется сложная индексация NumPy. 
   ~\lstinputlisting[firstline = 27, lastline = 29]{task2.py}
    \pagebreak
    \subsection{Вычисление скоростей}
        В модуле $task2.py$ описана функция $gen(size)$, которая в зависимости от значения параметра $size$ генерирует случайные тестовые данные разных объёмов.\\
        Время измеряется в IPython Notebook функцией $\verb"%timeit -o -q"$.\\       
        \begin{tabular}[t]{|p{5cm}|c|c|c|c|c|}
			\hline
            Значение $size$ & $0$ & $1$ & $2$ & $3$ & $4$ \\
            \hline
            Размеры матрицы $X$ & $70 \times 50$ & $100 \times 120$ & $520 \times 500$ & $1000 \times 1020$ & $5020 \times 5000$\\
            \hline
            Размеры векторов $i, j$ & $60$ & $110$ & $510$ & $1010$ & $5010$\\
            \hline
            Время работы векторного решения & $18~\mu{s}$ & $21~\mu{s}$ & $40~\mu{s}$ & $73~\mu{s}$ & $0.44~ms$\\
            \hline
            Время работы невекторного решения & $134~\mu{s}$ & $227~\mu{s}$ & $1.1~ms$ & $2.2~ms$ & $12.1~ms$\\
            \hline
            Время работы решения 3& $48~\mu{s}$ & $72~\mu{s}$ & $0.45~ms$ & $5~ms$ & $125~ms$\\
            \hline
        \end{tabular}
    \subsection{Вывод}
    \begin{figure}[!h]
        \centering
		\includegraphics[width = 0.8\textwidth]{task2.pdf}
        \caption{Задача 2. График зависимости скоростей разных реализаций от объёма входных данных}
        \label{task2}
   \end{figure}
    Как видно на рисунке \ref{task2}, векторная реализация работает быстрее остальных. Частично-векторная реализация работает быстрее невекторной на маленьких объемах данных. Но при росте объема данных замедляется, так как при выборе всех нужных строк сохраняется много лишней информации.
\pagebreak
\section{Задача 3}
    \subsection{Условие}
    Даны два вектора $x$ и $y$. Проверить, задают ли они одно и то же мультимножество.
    
    \subsection{Решение 1. Векторизованное}
    Чтобы проверить два массива на совпадение в смысле мультимнжеств, можно оба массива отсортировать и сравнить соответствующие элементы. Используется сортировка из NumPy($np.sort()$) и функция ($np.all()$) для проверки совпадения всех элементов.
   ~\lstinputlisting[firstline = 6, lastline = 7]{task3.py}
    
    \subsection{Решение 2. Невекторизованное}
    Чтобы проверить два массива на совпадение в смысле мультимнжеств, можно оба массива отсортировать и сравнить как $list$.
    Используется стандартная функция($sorted$) языка Python. 
    ~\lstinputlisting[firstline = 12, lastline = 13]{task3.py}
    
    \subsection{Решение 3}
    Чтобы проверить два массива на совпадение в смысле мультимнжеств, можно оба массива отсортировать и сравнить соответствующие элементы. Используется сортировка из NumPy($np.sort()$) и с помощью цикла $for$ проверяется совпрадение всех значений.
   ~\lstinputlisting[firstline = 18, lastline = 23]{task3.py}
    \pagebreak
    \subsection{Вычисление скоростей}
        В модуле $task3.py$ описана функция $gen(size)$, которая в зависимости от значения параметра $size$ генерирует случайные тестовые данные разных объёмов.\\
        Времена измеряются в IPython Notebook функцией $\verb"%timeit -o -q"$.\\       
        \begin{tabular}[t]{|p{5cm}|c|c|c|c|c|}
			\hline
            Значение $size$ & $0$ & $1$ & $2$ & $3$ & $4$ \\
            \hline
            Размеры векторов $x, y$ & $10$ & $100$ & $1000$ & $10000$ & $100000$\\
            \hline
            Время работы векторного решения & $78~\mu{s}$ & $96~\mu{s}$ & $162~\mu{s}$ & $1.2~ms$ & $12.7~ms$\\
            \hline
            Время работы невекторного решения & $30~\mu{s}$ & $0.3~ms$ & $2.6~ms$ & $18~ms$ & $180~ms$\\
            \hline
            Время работы решения 3& $65~\mu{s}$ & $118~\mu{s}$ & $288~\mu{s}$ & $2.8~ms$ & $28.4~ms$\\
            \hline
        \end{tabular}
    \subsection{Вывод}
    \begin{figure}[!h]
        \centering
		\includegraphics[width = 0.8\textwidth]{task3.pdf}
        \caption{Задача 3. График зависимости скоростей разных реализаций от объёма входных данных}
        \label{task3}
   \end{figure}
    Как видно на рисунке \ref{task3}, на больших объёмах данных, векторная реализация работает быстрее остальных, частично-векторная реализация работает быстрее невекторной, но медленнее векторной, и невекторизованная работает медленнее остальных. Но на маленьких объёмах очерёдность другая, так как время работы всех реализаций очень мало и сравнимо с погрешностью вычисления этого времени.
\pagebreak
\section{Задача 4}

    \subsection{Условие}
    Найти максимальный элемент в векторе $x$ среди элементов, перед которыми стоит нулевой. 
    
    \subsection{Решение 1. Векторизованное}
    Используются функции NumPy: $np.max()$ и $np.where()$.
   ~\lstinputlisting[firstline = 6, lastline = 7]{task4.py}
    
    \subsection{Решение 2. Невекторизованное}
    С помощью цикла $for$ каждый элемент вектора $x$ проверяется.
    ~\lstinputlisting[firstline = 12, lastline = 17]{task4.py}
    
    \subsection{Решение 3}
    С помощью функции $np.where()$ выбираются элементы, перед которыми в векторе $0$. Далее в цикле по выбранным элементам находится максимум. 
   ~\lstinputlisting[firstline = 22, lastline = 28]{task4.py}
    \pagebreak
    \subsection{Вычисление скоростей}
        В модуле $task4.py$ описана функция $gen(size)$, которая в зависимости от значения параметра $size$ генерирует случайные тестовые данные разных объёмов.\\
        Время измеряется в IPython Notebook функцией $\verb"%timeit -o -q"$.\\       
        \begin{tabular}[t]{|p{5cm}|c|c|c|c|c|}
			\hline
            Значение $size$ & $0$ & $1$ & $2$ & $3$ & $4$ \\
            \hline
            Размеры вектора $x$ & $10$ & $100$ & $1000$ & $10000$ & $100000$\\
            \hline
            Время работы векторного решения & $47.6~\mu{s}$ & $48~\mu{s}$ & $64~\mu{s}$ & $271~\mu{s}$ & $2.2~ms$\\
            \hline
            Время работы невекторного решения & $32~\mu{s}$ & $150~\mu{s}$ & $1.4~ms$ & $14~ms$ & $134~ms$\\
            \hline
            Время работы решения 3& $35~\mu{s}$ & $51~\mu{s}$ & $178~\mu{s}$ & $1.8~ms$ & $15~ms$\\
            \hline
        \end{tabular}
    \subsection{Вывод}
    \begin{figure}[!h]
        \centering
		\includegraphics[width = 0.8\textwidth]{task4.pdf}
        \caption{Задача 4. График зависимости скоростей разных реализаций от объёма входных данных}
        \label{task4}
   \end{figure}
    Как видно на рисунке \ref{task4}, на больших объёмах данных векторная реализация работает быстрее остальных, частично-векторная реализация работает быстрее невекторной, но медленнее векторной, и невекторизованная работает медленнее остальных. Но на маленьких объёмах очерёдность другая, так как время работы всех реализаций очень мало и сравнимо с погрешностью вычисления этого времени.
\pagebreak   
\section{Задача 5}
    \subsection{Условие}
    Дан трёхмерный массив, содержащий изображение, размера $(height, width, numChannels)$, а также вектор длины $numChannels$. Сложить каналы изображения с указанными весами, и вернуть результат в виде матрицы размера $(height, width)$. Преобразуйте цветное изображение в оттенки серого, использовав коэффициенты $np.array([0.299, 0.587, 0.114])$.
        
    \subsection{Решение 1. Векторизованное}
    Используется broadcasting.
   ~\lstinputlisting[firstline = 7, lastline = 8]{task5.py}
    
    \subsection{Решение 2. Невекторизованное}
    Все элементы трёхмерного массива $img$ просматриваются и добавляются в результат с соответствующими коэффициентами вектора $ch$.
    ~\lstinputlisting[firstline = 14, lastline = 22]{task5.py}
    
    \subsection{Решение 3}
    Для каждого элемента вектора каналов с помощью broadcasting вычисляется двумерная матрица, которая добавляется в результирующую матрицу. 
   ~\lstinputlisting[firstline = 28, lastline = 34]{task5.py}
    \pagebreak
    \subsection{Вычисление скоростей}
        В модуле $task5.py$ описана функция $gen(size)$, которая в зависимости от значения параметра $size$ генерирует случайные тестовые данные разных объёмов.\\
        Время измеряется в IPython Notebook функцией $\verb"%timeit -o -q"$.\\       
        \begin{tabular}[t]{|p{5cm}|c|c|c|c|c|}
			\hline
            Значение $size$ & $0$ & $1$ & $2$ & $3$ & $4$ \\
            \hline
            $height$ & $10$ & $20$ & $40$ & $80$ & $160$\\
            \hline
            $width$ & $15$ & $30$ & $60$ & $120$ & $240$\\
            \hline
            $numChannels$ & $3$ & $5$ & $10$ & $20$ & $50$\\
            \hline
            Время работы векторного решения & $75~\mu{s}$ & $94~\mu{s}$ & $269~\mu{s}$ & $2.3~ms$ & $21~ms$\\
            \hline
            Время работы невекторного решения & $6~ms$ & $39~ms$ & $419~ms$ & $3.3~s$ & $32~s$\\
            \hline
            Время работы решения 3& $123~\mu{s}$ & $188~\mu{s}$ & $0.6~ms$ & $3.3~ms$ & $37~ms$\\
            \hline
        \end{tabular}
    \vspace{3cm}    
    \begin{figure}[!h]
        \centering
		\includegraphics[width = 0.45\textwidth]{red_autumn_leaves_water.png}~
		\includegraphics[width = 0.45\textwidth]{gray_autumn_leaves_water.png}
        \caption{Задача 5. Пример преобразование в оттенки серого}
    \end{figure}
    \pagebreak
    \subsection{Вывод}
    \begin{figure}[!h]
        \centering
		\includegraphics[width = 0.8\textwidth]{task5.pdf}
        \caption{Задача 5. График зависимости скоростей разных реализаций от объёма входных данных}
        \label{task5}
   \end{figure}
    Как видно на рисунке \ref{task5}, векторная реализация работает быстрее остальных, частично-векторная реализация работает быстрее невекторной, но медленнее векторной, и невекторизованная работает медленнее остальных. Это соответствует теоретическим соображениям.

\pagebreak
\section{Задача 6}
    \subsection{Условие}
    Реализовать кодирование длин серий (Run-length encoding). Дан вектор $x$. Необходимо вернуть кортеж из двух векторов одинаковой длины. Первый содержит числа, а второй~--- сколько раз их нужно повторить.
    
    \subsection{Решение 1. Векторизованное}
    $jump$~--- вектор таких индексов $i$ вектора $x$, для которых $x[i] - x[i-1] \neq 0$, включая $0$ и $len(x)$.
    Во 2 строке, с помощью функций NumPy вычисляется вектор $jump$. Ответ на задачу вычисляется с помощью сложной индексации $NumPy$.
   ~\lstinputlisting[firstline = 6, lastline = 8]{task6.py}
    
    \subsection{Решение 2. Невекторизованное}
    Просматриваются все значения вектора $x$ и учитываются в ответе.
    ~\lstinputlisting[firstline = 13, lastline = 22]{task6.py}
    
    \subsection{Решение 3}
    $jump$~--- вектор таких индексов $i$ вектора $x$, для которых $x[i] - x[i-1] \neq 0$, включая~$0$.
    Вектор $jump$ вычисляется без использования функций $NumPy$, а ответ с помощью сложной индексации $NumPy$.
   ~\lstinputlisting[firstline = 27, lastline = 32]{task6.py}
   
    \subsection{Вычисление скоростей}
        В модуле $task6.py$ описана функция $gen(size)$, которая в зависимости от значения параметра $size$ генерирует случайные тестовые данные разных объёмов.\\
        Время измеряется в IPython Notebook функцией $\verb"%timeit -o -q"$.\\       
        \begin{tabular}[t]{|p{5cm}|c|c|c|c|c|}
			\hline
            Значение $size$ & $0$ & $1$ & $2$ & $3$ & $4$ \\
            \hline
            Размер вектора $x$ & $100$ & $1000$ & $10000$ & $100000$ & $1000000$\\
            \hline
            Время работы векторного решения & $123~\mu{s}$ & $209~\mu{s}$ & $1.0~ms$ & $1.2~ms$ & $1.4~ms$\\
            \hline
            Время работы невекторного решения & $0.7~ms$ & $7.2~ms$ & $73~ms$ & $714~ms$ & $7.6~s$\\
            \hline
            Время работы решения 3& $0.7~ms$ & $6.8~ms$ & $67.7~ms$ & $670~ms$ & $7.1~s$\\
            \hline
        \end{tabular}
    \subsection{Вывод}
    \begin{figure}[!h]
        \centering
		\includegraphics[width = 0.8\textwidth]{task6.pdf}
        \caption{Задача 6. График зависимости скоростей разных реализаций от объёма входных данных}
        \label{task6}
   \end{figure}
    Как видно на рисунке \ref{task6}, векторная реализация работает быстрее остальных, частично-векторная реализация работает быстрее невекторной, но медленнее векторной, и невекторизованная работает медленнее остальных. Это соответствует теоретическим соображениям.
\section{Задача 7}
    \subsection{Условие}
    Даны две выборки объектов~--- $X$ и $Y$. Вычислить матрицу евклидовых расстояний между объектами.
    \subsection{Решение 1. Векторизованное}
    С помощью list comprehension для каждого вектора из $X$ вычисляется расстояние до всех векторов $Y$(с помощью broadcasting).
   ~\lstinputlisting[firstline = 7, lastline = 9]{task7.py}
    
    \subsection{Решение 2. Менее векторизованное}
    С помощью цикла $for$ для всех пар векторов $(x, y) : x \in X, y \in Y$ функциями NumPy вычисляется расстояние. 
    ~\lstinputlisting[firstline = 14, lastline = 19]{task7.py}
    
    \subsection{Решение 3. C использованием SciPy}
   ~\lstinputlisting[firstline = 24, lastline = 25]{task7.py}

    \subsection{Вычисление скоростей}
        В модуле $task7.py$ описана функция $gen(size)$, которая в зависимости от значения параметра $size$ генерирует случайные тестовые данные разных объёмов.\\
        Время измеряется в IPython Notebook функцией $\verb"%timeit -o -q"$.\\       
        \begin{tabular}[t]{|p{5cm}|c|c|c|c|c|}
			\hline
            Значение $size$ & $0$ & $1$ & $2$ & $3$ & $4$ \\
            \hline
            Размеры матрицы $X$ & $1 \times 13$ & $10 \times 8$ & $100 \times 5$ & $1000 \times 3$ & $10000 \times 2$\\
            \hline
            Размеры матрицы $Y$ & $10 \times 13$ & $10 \times 8$ & $10 \times 5$ & $10 \times 3$ & $10 \times 2$\\
            \hline
            Время работы векторного решения & $90~\mu{s}$ & $0.59~ms$ & $5.4~ms$ & $54~ms$ & $544~ms$\\
            \hline
            Время работы решения 2 & $457~\mu{s}$ & $4.4~ms$ & $42~ms$ & $445~ms$ & $4.4~s$\\
            \hline
            Время работы решения SciPy& $106~\mu{s}$ & $108~\mu{s}$ & $147~\mu{s}$ & $574~\mu{s}$ & $3.9~ms$\\
            \hline
        \end{tabular}
    \subsection{Вывод}
    \begin{figure}[!h]
        \centering
		\includegraphics[width = 0.8\textwidth]{task7.pdf}
        \caption{Задача 7.  График зависимости скоростей разных реализаций от объёма входных данных}
        \label{task7}
   \end{figure}
    Как видно на рисунке \ref{task7}, реализация SciPy работает быстрее остальных, а векторная лучше менее-векторной. Это соответствует теоретическим соображениям.
\pagebreak
\section{Задача 8}
\subsection{Условие}
    Реализовать функцию вычисления логарифма плотности многомерного нормального распределения \\ Входные параметры: точки $X$, размер $(N, D)$, мат. ожидание $m$, вектор длины $D$, матрица ковариаций $C$, размер $(D, D)$. Сравнить с $scipy.stats.multivariate_normal(m, C).logpdf(X)$ как по скорости работы, так и по точности вычислений.
    \subsection{Решение 1. Векторизованное}
    Формула плотности невырожденного нормального распределения выполнена для всей матрицы $X$.
   ~\lstinputlisting[firstline = 9, lastline = 13]{task8.py}
    
    \subsection{Решение 2. Менее векторизованное}
    Формула плотности невырожденного нормального распределения выполнена для каждого вектора матрицы $X$.
    ~\lstinputlisting[firstline = 20, lastline = 27]{task8.py}
    
    \subsection{Решение 3. С использованием SciPy}
   ~\lstinputlisting[firstline = 34, lastline = 35]{task8.py}
    \pagebreak
    \subsection{Вычисление скоростей}
        В модуле $task8.py$ описана функция $gen(size)$, которая в зависимости от значения параметра $size$ генерирует случайные тестовые данные разных объёмов.\\
        Время измеряется в IPython Notebook функцией $\verb"%timeit -o -q"$.\\       
        \begin{tabular}[t]{|p{5cm}|c|c|c|c|c|}
			\hline
            Значение $size$ & $0$ & $1$ & $2$ & $3$ & $4$ \\
            \hline
            Размеры матрицы $X$ & $5 \times 5$ & $10 \times 10$ & $20 \times 20$ & $40 \times 40$ & $80 \times 80$\\
            \hline
            Время работы векторного решения & $315~\mu{s}$ & $370~\mu{s}$ & $0.5~ms$ & $0.8~ms$ & $1.8~ms$\\
            \hline
            Время работы решения 2& $1.3~ms$ & $2.8~ms$ & $7~ms$ & $19.8~ms$ & $103~ms$\\
            \hline
            Время работы SciPy решения& $1~ms$ & $1.2~ms$ & $1.6~ms$ & $2.4~ms$ & $5.5~ms$\\
            \hline
        \end{tabular}
    \subsection{Вывод}
    \begin{figure}[!h]
        \centering
		\includegraphics[width = 0.8\textwidth]{task8.pdf}
        \caption{Задача 8.  График зависимости скоростей разных реализаций от объёма входных данных}
        \label{task8}
   \end{figure}
    Как видно на рисунке \ref{task8}, векторная реализация работает быстрее остальных, частично-векторная реализация работает быстрее невекторной, но медленнее векторной, и невекторизованная работает медленнее остальных. Это соответствует теоретическим соображениям. 
    
    Опытным путём выяснено, что абсолютная погрешность слабо зависит от объёма исходных данных и колеблется от $10^{-15}$ до $10^{-7}$  
      
    
\end{document}











